{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Sqooler","text":"<p>Sqooler is a pydantic based SDK that allows you to receive jobs for quantum quantum hardware in a reliable fashion. It is therefore meant for the developer and quantum hardware owner who wants to provide a cloud access to their code in a secure fashion. A few important features:</p> <ul> <li>The PC never has to grant access privileges to any outside contributor.</li> <li>The remote jobs are heavily controlled through pydantic.</li> <li>Simple setup through templates.</li> </ul>"},{"location":"#our-related-projects","title":"Our related projects","text":"<ul> <li><code>labscript-qc-example</code> - Template to provide cloud access to your labscript code.</li> <li><code>sqooler-example</code> - Template to provide cloud access to your simulator.</li> <li><code>qlued</code> - Webkit for user management etc.</li> </ul>"},{"location":"#related-projects","title":"Related projects","text":"<ul> <li><code>labscript</code> - The labscript suite is a powerful and extensible framework for experiment composition, control, execution, and analysis.</li> <li><code>qiskit-cold-atom</code> - qiskit code to access cold atoms as an end user.</li> </ul>"},{"location":"contributing/","title":"Welcome to the sqooler contributing guide","text":"<p>Thank you for investing your time in potentially contributing to our project! Any contribution you make will be reflected on the repository of the open source project sqooler .</p> <p>You can contribute to the sqooler  content and site in several ways, which we will present you below. </p>"},{"location":"contributing/#discussions","title":"Discussions","text":"<p>Discussions are where we have conversations.</p> <p>If you'd like help troubleshooting a sqooler PR you're working on, have a great new idea, or want to share something amazing you've learned about quantum hardware access, join us in discussions.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Issues are used to track tasks that contributors can help with. </p> <p>If you've found something in the content or the code that should be updated, search open issues to see if someone else has reported the same thing. If it's something new, open an issue here. We'll use the issue to have a conversation about the problem you want to fix.</p>"},{"location":"contributing/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a problem with the docs, search if an issue already exists. If a related issue doesn't exist, you can open a new issue.</p>"},{"location":"contributing/#solve-an-issue","title":"Solve an issue","text":"<p>Scan through our existing issues to find one that interests you. You can narrow down the search using labels as filters. See Labels for more information. As a general rule, we don\u2019t assign issues to anyone. If you find an issue to work on, you are welcome to open a PR with a fix.</p>"},{"location":"contributing/#make-changes-in-the-github-ui","title":"Make Changes in the github UI","text":"<p>Click Make a contribution at the top of any page to make small changes such as a typo, sentence fix, or a broken link. This takes you to the .md file where you can make your changes and create a pull request for a review.</p>"},{"location":"contributing/#commit-your-update","title":"Commit your update","text":"<p>Commit the changes once you are happy with them. Don't forget to self-review to speed up the review process .</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>A pull request is a way to suggest changes in our repository. When we merge those changes, they should be deployed to the live site almost immediately. </p> <p>So when you're finished with the changes, create a pull request, also known as a PR.</p> <ul> <li>Fill the description so that we can review your PR. This template helps reviewers understand your changes as well as the purpose of your pull request. </li> <li>Don't forget to link PR to issue if you are solving one.</li> <li>Enable the checkbox to allow maintainer edits so the branch can be updated for a merge. Once you submit your PR, a sqooler team member will review your proposal. We may ask questions or request additional information.</li> <li>We may ask for changes to be made before a PR can be merged, either using suggested changes or pull request comments. You can apply suggested changes directly through the UI. You can make any other changes in your fork, then commit them to your branch.</li> <li>As you update your PR and apply changes, mark each conversation as resolved.</li> <li>If you run into any merge issues, checkout this git tutorial to help you resolve merge conflicts and other issues.</li> </ul>"},{"location":"contributing/#your-pr-is-merged","title":"Your PR is merged!","text":"<p>Congratulations  The sqooler team thanks you . </p> <p>Once your PR is merged, your contributions will be publicly visible on the sqooler repo. </p> <p>Now you are part of the sqooler community. Thank you for your contributions! We look forward to working with you to make our project even better.</p>"},{"location":"contributing/#attribution","title":"Attribution","text":"<p>These contribution guidelines are adapted from the contribution guidelines for Github docs, available online on the github.</p>"},{"location":"releases/","title":"Release information","text":"<p>In this guide we will cover the key information about the different releases.</p>"},{"location":"releases/#v04","title":"v0.4","text":"<p>This release focused on better typing with <code>pydantic</code> and a simpler deployment on the back-end side.</p> <p>What Changed:</p> <ul> <li>Introduce the <code>StatusMsgDict</code> for proper typing of status messages </li> <li>Enforce cleaner typing of <code>ExperimentDict</code> </li> <li>Improved testing of the <code>Spooler</code> </li> <li>Introduce the <code>GateDict</code> to properly type the <code>gate_list_from_dict</code></li> <li>Improved testing, typing and error handling of the <code>gen_circuit</code> </li> <li>Added <code>LabscriptSpooler</code> class </li> <li>Add the <code>gen_script</code> from the labscriptspooler nd created the <code>spoolers</code> module</li> </ul>"},{"location":"schemes/","title":"API documentation of schemes","text":"<p>The module that contains common logic for schemes, validation etc. There is no obvious need, why this code should be touch in a new back-end.</p>"},{"location":"schemes/#src.sqooler.schemes.BackendConfigSchemaIn","title":"<code>BackendConfigSchemaIn</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The schema send in to detail the configuration of the backend. This is uploaded to the storage provider.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class BackendConfigSchemaIn(BaseModel):\n    \"\"\"\n    The schema send in to detail the configuration of the backend.\n    This is uploaded to the storage provider.\n    \"\"\"\n\n    description: str = Field(description=\"A description for the backend\")\n    version: str = Field(description=\"The backend version in the form X.Y.Z\")\n    display_name: Optional[str] = Field(\n        description=\" Alternate name field for the backend\"\n    )\n    cold_atom_type: str = Field(\n        description=\"The type of cold atom system that is simulated. Non standard qiskit field.\"\n    )\n    gates: list = Field(\n        description=\"The list of GateConfig objects for the basis gates of the backend\"\n    )\n    max_experiments: int = Field(\n        description=\"The maximum number of experiments per job\"\n    )\n    max_shots: int = Field(\n        description=\"The maximum number of shots allowed on the backend\"\n    )\n    simulator: bool = Field(description=\"True if the backend is a simulator\")\n    supported_instructions: list[str] = Field(\n        description=\"Instructions supported by the backend.\"\n    )\n    num_wires: int = Field(description=\"The number of qubits / wires for the backend\")\n    wire_order: str = Field(\n        description=\"The wire order of the backend. Either linear or interleaved.\"\n    )\n    num_species: int = Field(description=\"The number of species in the system.\")\n    operational: bool = Field(description=\"True if the backend is operational\")\n    pending_jobs: Optional[int] = Field(\n        default=None, description=\"The number of pending jobs on the backend\"\n    )\n    status_msg: Optional[str] = Field(\n        default=None, description=\"The status message for the backend\"\n    )\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.BackendConfigSchemaOut","title":"<code>BackendConfigSchemaOut</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The schema send out to detail the configuration of the backend. We follow the conventions of the qiskit configuration dictionary here.</p> <p>Will becomes compatible with qiskit.providers.models.BackendConfiguration</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class BackendConfigSchemaOut(BaseModel):\n    \"\"\"\n    The schema send out to detail the configuration of the backend. We follow the\n    conventions of the qiskit configuration dictionary here.\n\n    Will becomes compatible with qiskit.providers.models.BackendConfiguration\n    \"\"\"\n\n    description: str = Field(description=\"A description for the backend\")\n    display_name: str = Field(description=\" Alternate name field for the backend\")\n    conditional: bool = Field(\n        default=False, description=\"True if the backend supports conditional operations\"\n    )\n    coupling_map: str = Field(\n        default=\"linear\", description=\"The coupling map for the device\"\n    )\n    dynamic_reprate_enabled: bool = Field(\n        default=False,\n        description=\"whether delay between programs can be set dynamically \",\n    )\n    local: bool = Field(\n        default=False, description=\"True if the backend is local or False if remote\"\n    )\n    memory: bool = Field(default=False, description=\"True if backend supports memory\")\n    open_pulse: bool = Field(default=False, description=\"True if backend is OpenPulse\")\n    backend_version: str = Field(description=\"The backend version in the form X.Y.Z\")\n    n_qubits: int = Field(description=\"The number of qubits / wires for the backend\")\n    backend_name: str = Field(description=\"The backend name\")\n    basis_gates: list[str] = Field(\n        description=\"The list of strings for the basis gates of the backends\"\n    )\n    max_experiments: int = Field(\n        description=\"The maximum number of experiments per job\"\n    )\n    max_shots: int = Field(\n        description=\"The maximum number of shots allowed on the backend\"\n    )\n    simulator: bool = Field(description=\"True if the backend is a simulator\")\n    gates: list = Field(\n        description=\"The list of GateConfig objects for the basis gates of the backend\"\n    )\n    supported_instructions: list[str] = Field(\n        description=\"Instructions supported by the backend.\"\n    )\n    cold_atom_type: str = Field(\n        description=\"The type of cold atom system that is simulated. Non standard qiskit field.\"\n    )\n    wire_order: str = Field(\n        description=(\n            \"The wire order of the backend. Either linear or interleaved.\"\n            \" Non standard qiskit field.\"\n        )\n    )\n    num_species: int = Field(\n        description=\"The number of species in the system. Non standard qiskit field.\"\n    )\n    url: Optional[str] = Field(default=None, description=\"The url of the backend\")\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.BackendStatusSchemaOut","title":"<code>BackendStatusSchemaOut</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The schema for the status of a backend. Follows the conventions of the <code>qiskit.providers.models.BackendStatus</code>.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class BackendStatusSchemaOut(BaseModel):\n    \"\"\"\n    The schema for the status of a backend. Follows the conventions of the\n    `qiskit.providers.models.BackendStatus`.\n    \"\"\"\n\n    backend_name: str = Field(description=\"The name of the backend\")\n    backend_version: str = Field(\n        description=\"The version of the backend. Of the form X.Y.Z\"\n    )\n    operational: bool = Field(description=\"True if the backend is operational\")\n    pending_jobs: int = Field(description=\"The number of pending jobs on the backend\")\n    status_msg: str = Field(description=\"The status message for the backend\")\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.DropboxLoginInformation","title":"<code>DropboxLoginInformation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The login information for the dropbox</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class DropboxLoginInformation(BaseModel):\n    \"\"\"\n    The login information for the dropbox\n    \"\"\"\n\n    app_key: str\n    app_secret: str\n    refresh_token: str\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.ExperimentDict","title":"<code>ExperimentDict</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class that defines the structure of the experiments.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class ExperimentDict(BaseModel):\n    \"\"\"\n    A class that defines the structure of the experiments.\n    \"\"\"\n\n    header: dict = Field(description=\"Contains centralized information about the job.\")\n    shots: int = Field(description=\"number of shots in the experiment.\")\n    success: bool = Field(description=\"True if experiment ran successfully.\")\n    data: dict = Field(description=\"dictionary of results for the experiment.\")\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.GateDict","title":"<code>GateDict</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The most basic class for a gate as it is communicated in the json API.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class GateDict(BaseModel):\n    \"\"\"\n    The most basic class for a gate as it is communicated in\n    the json API.\n    \"\"\"\n\n    name: str = Field(description=\"The name of the gate\")\n    wires: list[int] = Field(description=\"The wires on which the gate acts\")\n    params: list[float] = Field(description=\"The parameters of the gate\")\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.GateInstruction","title":"<code>GateInstruction</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The basic class for all the gate intructions of a backend. Any gate has to have the following attributes.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class GateInstruction(BaseModel):\n    \"\"\"\n    The basic class for all the gate intructions of a backend.\n    Any gate has to have the following attributes.\n    \"\"\"\n\n    name: str\n    parameters: str\n    description: str\n    coupling_map: list\n    qasm_def: str = \"{}\"\n    is_gate: bool = True\n\n    @classmethod\n    def config_dict(cls) -&gt; dict:\n        \"\"\"\n        Give back the properties of the instruction such as needed for the server.\n        \"\"\"\n        return {\n            \"coupling_map\": cls.model_fields[\"coupling_map\"].default,\n            \"description\": cls.model_fields[\"description\"].default,\n            \"name\": cls.model_fields[\"name\"].default,\n            \"parameters\": [cls.model_fields[\"parameters\"].default],\n            \"qasm_def\": cls.model_fields[\"qasm_def\"].default,\n        }\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.GateInstruction.config_dict","title":"<code>config_dict()</code>  <code>classmethod</code>","text":"<p>Give back the properties of the instruction such as needed for the server.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>@classmethod\ndef config_dict(cls) -&gt; dict:\n    \"\"\"\n    Give back the properties of the instruction such as needed for the server.\n    \"\"\"\n    return {\n        \"coupling_map\": cls.model_fields[\"coupling_map\"].default,\n        \"description\": cls.model_fields[\"description\"].default,\n        \"name\": cls.model_fields[\"name\"].default,\n        \"parameters\": [cls.model_fields[\"parameters\"].default],\n        \"qasm_def\": cls.model_fields[\"qasm_def\"].default,\n    }\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.LabscriptParams","title":"<code>LabscriptParams</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class that defines the parameters for the labscript folders.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class LabscriptParams(BaseModel):\n    \"\"\"\n    A class that defines the parameters for the labscript folders.\n    \"\"\"\n\n    exp_script_folder: str = Field(\n        description=\"The relative path to the experimental scripts.\"\n    )\n    t_wait: float = Field(description=\"The time to wait between checks.\")\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.LocalLoginInformation","title":"<code>LocalLoginInformation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The login information for a local storage provider.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class LocalLoginInformation(BaseModel):\n    \"\"\"\n    The login information for a local storage provider.\n    \"\"\"\n\n    base_path: str = Field(\n        description=\"The base path of the storage provider on your local file system.\"\n    )\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.MongodbLoginInformation","title":"<code>MongodbLoginInformation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The login information for MongoDB</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class MongodbLoginInformation(BaseModel):\n    \"\"\"\n    The login information for MongoDB\n    \"\"\"\n\n    mongodb_username: str\n    mongodb_password: str\n    mongodb_database_url: str\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.ResultDict","title":"<code>ResultDict</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class that defines the structure of results. It is closely related to the qiskit class qiskit.result.Result.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class ResultDict(BaseModel):\n    \"\"\"\n    A class that defines the structure of results. It is closely related to the\n    qiskit class qiskit.result.Result.\n    \"\"\"\n\n    backend_name: Optional[str] = Field(\n        default=None, description=\"The name of the backend\"\n    )\n    display_name: str = Field(description=\"alternate name field for the backend\")\n    backend_version: str = Field(description=\"backend version, in the form X.Y.Z.\")\n    job_id: str = Field(description=\"unique execution id from the backend.\")\n    qobj_id: Optional[str] = Field(default=None, description=\"user-generated Qobj id.\")\n    success: bool = Field(description=\"True if complete input qobj executed correctly.\")\n    status: str = Field(description=\"status of job execution.\")\n    header: dict = Field(description=\"Contains centralized information about the job.\")\n    results: list[ExperimentDict] = Field(\n        description=\"corresponding results for array of experiments of the input qobj\"\n    )\n</code></pre>"},{"location":"schemes/#src.sqooler.schemes.StatusMsgDict","title":"<code>StatusMsgDict</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class that defines the structure of the status messages.</p> Source code in <code>src/sqooler/schemes.py</code> <pre><code>class StatusMsgDict(BaseModel):\n    \"\"\"\n    A class that defines the structure of the status messages.\n    \"\"\"\n\n    job_id: str = Field(description=\"unique execution id from the backend.\")\n    status: str = Field(description=\"status of job execution.\")\n    detail: str = Field(description=\"detailed status of job execution.\")\n    error_message: str = Field(description=\"error message of job execution.\")\n</code></pre>"},{"location":"spoolers/","title":"API documentation of spoolers","text":"<p>This module contains the code for the Spooler classes and its helpers. So it mainly meant to be deployed on the back-end side for people that would like to perform calculations and work through the job queue.</p> <p>The main class is the <code>Spooler</code> class. It is the class that is used for the simulators.  The <code>LabscriptSpooler</code> class is a specialized version of the <code>Spooler</code> class that allows us to execute  jobs in labscript directly.</p>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler","title":"<code>BaseSpooler</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for spoolers. They are the main logic of the back-end.</p> <p>Attributes:</p> Name Type Description <code>ins_schema_dict</code> <p>A dictionary the contains all the allowed instructions for this spooler.</p> <code>device_config</code> <p>A dictionary that some main config params for the experiment.</p> <code>n_wires</code> <p>maximum number of wires for the spooler</p> <code>n_max_shots</code> <p>the maximum number of shots for the spooler</p> <code>version</code> <p>the version of the backend</p> <code>cold_atom_type</code> <p>the type of cold atom that is used in the experiment</p> <code>n_max_experiments</code> <p>the maximum number of experiments that can be executed</p> <code>wire_order</code> <p>the order of the wires</p> <code>num_species</code> <p>the number of atomic species in the experiment</p> <code>operational</code> <p>is the backend ready for access by remote users ?</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>class BaseSpooler(ABC):\n    \"\"\"\n    Abstract base class for spoolers. They are the main logic of the back-end.\n\n    Attributes:\n        ins_schema_dict : A dictionary the contains all the allowed instructions for this spooler.\n        device_config: A dictionary that some main config params for the experiment.\n        n_wires: maximum number of wires for the spooler\n        n_max_shots: the maximum number of shots for the spooler\n        version: the version of the backend\n        cold_atom_type: the type of cold atom that is used in the experiment\n        n_max_experiments: the maximum number of experiments that can be executed\n        wire_order: the order of the wires\n        num_species: the number of atomic species in the experiment\n        operational: is the backend ready for access by remote users ?\n    \"\"\"\n\n    def __init__(\n        self,\n        ins_schema_dict: dict,\n        device_config: Type[BaseModel],\n        n_wires: int,\n        description: str = \"\",\n        n_max_shots: int = 1000,\n        version: str = \"0.0.1\",\n        cold_atom_type: str = \"spin\",\n        n_max_experiments: int = 15,\n        wire_order: str = \"interleaved\",\n        num_species: int = 1,\n        operational: bool = True,\n    ):\n        \"\"\"\n        The constructor of the class.\n        \"\"\"\n        self.ins_schema_dict = ins_schema_dict\n        self.device_config = device_config\n        self.n_max_shots = n_max_shots\n        self.n_wires = n_wires\n        self.description = description\n        self.version = version\n        self.cold_atom_type = cold_atom_type\n        self.n_max_experiments = n_max_experiments\n        self.wire_order = wire_order\n        self.num_species = num_species\n        self._display_name: str = \"\"\n        self.operational = operational\n\n    def check_experiment(self, exper_dict: dict) -&gt; tuple[str, bool]:\n        \"\"\"\n        Check the validity of the experiment.\n        This has to be implement in each subclass extra.\n\n        Args:\n            exper_dict: The dictionary that contains the logic and should\n                be verified.\n\n        Returns:\n            str: The error message\n            bool: Is the experiment ok ?\n        \"\"\"\n        try:\n            self.device_config(**exper_dict)\n            return \"\", True\n        except ValidationError as err:\n            return str(err), False\n\n    def get_configuration(self) -&gt; BackendConfigSchemaIn:\n        \"\"\"\n        Sends back the configuration dictionary of the spooler.\n\n        Returns:\n            The configuration dictionary of the spooler.\n        \"\"\"\n        gate_list = []\n        for _, ins_obj in self.ins_schema_dict.items():\n            if \"is_gate\" in ins_obj.model_fields:\n                gate_list.append(ins_obj.config_dict())\n        backend_config_dict = {\n            \"description\": self.description,\n            \"version\": self.version,\n            \"cold_atom_type\": self.cold_atom_type,\n            \"gates\": gate_list,\n            \"max_experiments\": self.n_max_experiments,\n            \"max_shots\": self.n_max_shots,\n            \"simulator\": True,\n            \"supported_instructions\": list(self.ins_schema_dict.keys()),\n            \"num_wires\": self.n_wires,\n            \"wire_order\": self.wire_order,\n            \"num_species\": self.num_species,\n            \"operational\": self.operational,\n            \"display_name\": self.display_name,\n        }\n        return BackendConfigSchemaIn(**backend_config_dict)\n\n    def check_instructions(self, ins_list: list) -&gt; tuple[str, bool]:\n        \"\"\"\n        Check all the instruction to make sure that they are valid and part\n        of the allowed instructions.\n\n        Args:\n            ins_list: The list of instructions that should be checked.\n\n        Returns:\n            str: The error message\n            bool: Are the instructions ok ?\n        \"\"\"\n        err_code = \"\"\n        exp_ok = False\n        # first check that we actually have any instructions safed in the ins_schema_dict\n        if len(self.ins_schema_dict) == 0:\n            err_code = \"No instructions allowed. Add instructions to the spooler.\"\n            exp_ok = False\n            return err_code, exp_ok\n\n        for ins in ins_list:\n            try:\n                gate_instr = gate_dict_from_list(ins)\n                # see if the instruction is part of the allowed instructions\n                if gate_instr.name not in self.ins_schema_dict.keys():\n                    err_code = \"Instruction not allowed.\"\n                    exp_ok = False\n                    return err_code, exp_ok\n\n                # now verify that the parameters are ok\n                gate_dict = gate_instr.model_dump()\n                self.ins_schema_dict[gate_instr.name](**gate_dict)\n                exp_ok = True\n            except ValidationError as err:\n                err_code = \"Error in instruction \" + str(err)\n                exp_ok = False\n            if not exp_ok:\n                break\n        return err_code, exp_ok\n\n    def check_dimension(self, json_dict: dict) -&gt; tuple[str, bool]:\n        \"\"\"\n        Make sure that the Hilbert space dimension is not too large.\n\n        It can be implemented in the class that inherits, but it is not necessary.\n        So this is only a placeholder.\n\n        Args:\n            json_dict: the dictonary with the instructions\n\n        Returns:\n            str: the error message\n            bool: is the dimension ok ?\n        \"\"\"\n        # pylint: disable=W0613\n        return \"\", True\n\n    def check_json_dict(self, json_dict: dict) -&gt; tuple[str, bool]:\n        \"\"\"\n        Check if the json file has the appropiate syntax.\n\n        Args:\n            json_dict (dict): the dictonary that we will test.\n\n        Returns:\n            bool: is the expression having the appropiate syntax ?\n        \"\"\"\n        err_code = \"No instructions received.\"\n        exp_ok = False\n        for expr in json_dict:\n            err_code = \"Wrong experiment name or too many experiments\"\n            # Fix this pylint issue whenever you have time, but be careful !\n            # pylint: disable=W0702\n            try:\n                exp_ok = (\n                    expr.startswith(\"experiment_\")\n                    and expr[11:].isdigit()\n                    and (int(expr[11:]) &lt;= self.n_max_experiments)\n                )\n            except:\n                exp_ok = False\n                break\n            if not exp_ok:\n                break\n            # test the structure of the experiment\n            err_code, exp_ok = self.check_experiment(json_dict[expr])\n            if not exp_ok:\n                break\n            # time to check the structure of the instructions\n            ins_list = json_dict[expr][\"instructions\"]\n            err_code, exp_ok = self.check_instructions(ins_list)\n            if not exp_ok:\n                break\n        return err_code.replace(\"\\n\", \"..\"), exp_ok\n\n    @property\n    def display_name(self) -&gt; str:\n        \"\"\"\n        The name of the spooler.\n        \"\"\"\n        return self._display_name\n\n    @display_name.setter\n    def display_name(self, value: str) -&gt; None:\n        if isinstance(value, str):  # Check if the provided value is a string\n            self._display_name = value\n        else:\n            raise ValueError(\"display_name must be a string\")\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.display_name","title":"<code>display_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the spooler.</p>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.__init__","title":"<code>__init__(ins_schema_dict, device_config, n_wires, description='', n_max_shots=1000, version='0.0.1', cold_atom_type='spin', n_max_experiments=15, wire_order='interleaved', num_species=1, operational=True)</code>","text":"<p>The constructor of the class.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def __init__(\n    self,\n    ins_schema_dict: dict,\n    device_config: Type[BaseModel],\n    n_wires: int,\n    description: str = \"\",\n    n_max_shots: int = 1000,\n    version: str = \"0.0.1\",\n    cold_atom_type: str = \"spin\",\n    n_max_experiments: int = 15,\n    wire_order: str = \"interleaved\",\n    num_species: int = 1,\n    operational: bool = True,\n):\n    \"\"\"\n    The constructor of the class.\n    \"\"\"\n    self.ins_schema_dict = ins_schema_dict\n    self.device_config = device_config\n    self.n_max_shots = n_max_shots\n    self.n_wires = n_wires\n    self.description = description\n    self.version = version\n    self.cold_atom_type = cold_atom_type\n    self.n_max_experiments = n_max_experiments\n    self.wire_order = wire_order\n    self.num_species = num_species\n    self._display_name: str = \"\"\n    self.operational = operational\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.check_dimension","title":"<code>check_dimension(json_dict)</code>","text":"<p>Make sure that the Hilbert space dimension is not too large.</p> <p>It can be implemented in the class that inherits, but it is not necessary. So this is only a placeholder.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>the dictonary with the instructions</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the error message</p> <code>bool</code> <code>bool</code> <p>is the dimension ok ?</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def check_dimension(self, json_dict: dict) -&gt; tuple[str, bool]:\n    \"\"\"\n    Make sure that the Hilbert space dimension is not too large.\n\n    It can be implemented in the class that inherits, but it is not necessary.\n    So this is only a placeholder.\n\n    Args:\n        json_dict: the dictonary with the instructions\n\n    Returns:\n        str: the error message\n        bool: is the dimension ok ?\n    \"\"\"\n    # pylint: disable=W0613\n    return \"\", True\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.check_experiment","title":"<code>check_experiment(exper_dict)</code>","text":"<p>Check the validity of the experiment. This has to be implement in each subclass extra.</p> <p>Parameters:</p> Name Type Description Default <code>exper_dict</code> <code>dict</code> <p>The dictionary that contains the logic and should be verified.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message</p> <code>bool</code> <code>bool</code> <p>Is the experiment ok ?</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def check_experiment(self, exper_dict: dict) -&gt; tuple[str, bool]:\n    \"\"\"\n    Check the validity of the experiment.\n    This has to be implement in each subclass extra.\n\n    Args:\n        exper_dict: The dictionary that contains the logic and should\n            be verified.\n\n    Returns:\n        str: The error message\n        bool: Is the experiment ok ?\n    \"\"\"\n    try:\n        self.device_config(**exper_dict)\n        return \"\", True\n    except ValidationError as err:\n        return str(err), False\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.check_instructions","title":"<code>check_instructions(ins_list)</code>","text":"<p>Check all the instruction to make sure that they are valid and part of the allowed instructions.</p> <p>Parameters:</p> Name Type Description Default <code>ins_list</code> <code>list</code> <p>The list of instructions that should be checked.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message</p> <code>bool</code> <code>bool</code> <p>Are the instructions ok ?</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def check_instructions(self, ins_list: list) -&gt; tuple[str, bool]:\n    \"\"\"\n    Check all the instruction to make sure that they are valid and part\n    of the allowed instructions.\n\n    Args:\n        ins_list: The list of instructions that should be checked.\n\n    Returns:\n        str: The error message\n        bool: Are the instructions ok ?\n    \"\"\"\n    err_code = \"\"\n    exp_ok = False\n    # first check that we actually have any instructions safed in the ins_schema_dict\n    if len(self.ins_schema_dict) == 0:\n        err_code = \"No instructions allowed. Add instructions to the spooler.\"\n        exp_ok = False\n        return err_code, exp_ok\n\n    for ins in ins_list:\n        try:\n            gate_instr = gate_dict_from_list(ins)\n            # see if the instruction is part of the allowed instructions\n            if gate_instr.name not in self.ins_schema_dict.keys():\n                err_code = \"Instruction not allowed.\"\n                exp_ok = False\n                return err_code, exp_ok\n\n            # now verify that the parameters are ok\n            gate_dict = gate_instr.model_dump()\n            self.ins_schema_dict[gate_instr.name](**gate_dict)\n            exp_ok = True\n        except ValidationError as err:\n            err_code = \"Error in instruction \" + str(err)\n            exp_ok = False\n        if not exp_ok:\n            break\n    return err_code, exp_ok\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.check_json_dict","title":"<code>check_json_dict(json_dict)</code>","text":"<p>Check if the json file has the appropiate syntax.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>the dictonary that we will test.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>tuple[str, bool]</code> <p>is the expression having the appropiate syntax ?</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def check_json_dict(self, json_dict: dict) -&gt; tuple[str, bool]:\n    \"\"\"\n    Check if the json file has the appropiate syntax.\n\n    Args:\n        json_dict (dict): the dictonary that we will test.\n\n    Returns:\n        bool: is the expression having the appropiate syntax ?\n    \"\"\"\n    err_code = \"No instructions received.\"\n    exp_ok = False\n    for expr in json_dict:\n        err_code = \"Wrong experiment name or too many experiments\"\n        # Fix this pylint issue whenever you have time, but be careful !\n        # pylint: disable=W0702\n        try:\n            exp_ok = (\n                expr.startswith(\"experiment_\")\n                and expr[11:].isdigit()\n                and (int(expr[11:]) &lt;= self.n_max_experiments)\n            )\n        except:\n            exp_ok = False\n            break\n        if not exp_ok:\n            break\n        # test the structure of the experiment\n        err_code, exp_ok = self.check_experiment(json_dict[expr])\n        if not exp_ok:\n            break\n        # time to check the structure of the instructions\n        ins_list = json_dict[expr][\"instructions\"]\n        err_code, exp_ok = self.check_instructions(ins_list)\n        if not exp_ok:\n            break\n    return err_code.replace(\"\\n\", \"..\"), exp_ok\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.BaseSpooler.get_configuration","title":"<code>get_configuration()</code>","text":"<p>Sends back the configuration dictionary of the spooler.</p> <p>Returns:</p> Type Description <code>BackendConfigSchemaIn</code> <p>The configuration dictionary of the spooler.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def get_configuration(self) -&gt; BackendConfigSchemaIn:\n    \"\"\"\n    Sends back the configuration dictionary of the spooler.\n\n    Returns:\n        The configuration dictionary of the spooler.\n    \"\"\"\n    gate_list = []\n    for _, ins_obj in self.ins_schema_dict.items():\n        if \"is_gate\" in ins_obj.model_fields:\n            gate_list.append(ins_obj.config_dict())\n    backend_config_dict = {\n        \"description\": self.description,\n        \"version\": self.version,\n        \"cold_atom_type\": self.cold_atom_type,\n        \"gates\": gate_list,\n        \"max_experiments\": self.n_max_experiments,\n        \"max_shots\": self.n_max_shots,\n        \"simulator\": True,\n        \"supported_instructions\": list(self.ins_schema_dict.keys()),\n        \"num_wires\": self.n_wires,\n        \"wire_order\": self.wire_order,\n        \"num_species\": self.num_species,\n        \"operational\": self.operational,\n        \"display_name\": self.display_name,\n    }\n    return BackendConfigSchemaIn(**backend_config_dict)\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.LabscriptSpooler","title":"<code>LabscriptSpooler</code>","text":"<p>             Bases: <code>BaseSpooler</code></p> <p>A specialized spooler class that allows us to execute jobs in labscript directly. The main changes are that we need to add the job in a different way and connect it to a  <code>runmanager.remoteClient</code>. It adds three new attributes to the <code>BaseSpooler</code> class.</p> <p>Attributes:</p> Name Type Description <code>remote_client</code> <p>The remote client that is used to connect to the labscript server.</p> <code>labscript_params</code> <p>The parameters that are used to generate the folder for the shots.</p> <code>run</code> <p>The run object that is used to execute the labscript file.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>class LabscriptSpooler(BaseSpooler):\n    \"\"\"\n    A specialized spooler class that allows us to execute jobs in labscript directly.\n    The main changes are that we need to add the job in a different way and connect it to a\n     `runmanager.remoteClient`. It adds three new attributes to the `BaseSpooler` class.\n\n    Attributes:\n        remote_client: The remote client that is used to connect to the labscript server.\n        labscript_params: The parameters that are used to generate the folder for the shots.\n        run: The run object that is used to execute the labscript file.\n    \"\"\"\n\n    def __init__(\n        self,\n        ins_schema_dict: dict,\n        device_config: Type[BaseModel],\n        n_wires: int,\n        remote_client: Any,  # it would be really nice to fix this type\n        labscript_params: LabscriptParams,\n        run: Any,  # it would be really nice to fix this type\n        description: str = \"\",\n        n_max_shots: int = 1000,\n        version: str = \"0.0.1\",\n        cold_atom_type: str = \"spin\",\n        n_max_experiments: int = 15,\n        wire_order: str = \"interleaved\",\n        num_species: int = 1,\n        operational: bool = True,\n    ):\n        \"\"\"\n        The constructor of the class. The  arguments are the same as for the Spooler\n        class with two additions.\n\n\n        \"\"\"\n        super().__init__(\n            ins_schema_dict,\n            device_config,\n            n_wires,\n            description,\n            n_max_shots,\n            version,\n            cold_atom_type,\n            n_max_experiments,\n            wire_order,\n            num_species,\n            operational,\n        )\n        self.remote_client = remote_client\n        self.labscript_params = labscript_params\n        self.run = run\n\n    def add_job(\n        self, json_dict: dict, status_msg_dict: StatusMsgDict\n    ) -&gt; tuple[ResultDict, StatusMsgDict]:\n        \"\"\"\n        The function that translates the json with the instructions into some circuit\n        and executes it. It performs several checks for the job to see if it is properly\n        working. If things are fine the job gets added the list of things that should be\n        executed.\n\n        Args:\n            json_dict: The job dictonary of all the instructions.\n            status_msg_dict: the status dictionary of the job we are treating.\n\n        Returns:\n            result_dict: The dictionary with the results of the job.\n            status_msg_dict: The status dictionary of the job.\n        \"\"\"\n        job_id = status_msg_dict.job_id\n\n        result_draft: dict = {\n            \"display_name\": self.display_name,\n            \"backend_version\": self.version,\n            \"job_id\": job_id,\n            \"qobj_id\": None,\n            \"success\": True,\n            \"status\": \"finished\",\n            \"header\": {},\n            \"results\": [],\n        }\n        err_msg, json_is_fine = self.check_json_dict(json_dict)\n        if json_is_fine:\n            # check_hilbert_space_dimension\n            dim_err_msg, dim_ok = self.check_dimension(json_dict)\n            if dim_ok:\n                for exp in json_dict:\n                    exp_dict = {exp: json_dict[exp]}\n                    # prepare the shots folder\n                    self.remote_client.reset_shot_output_folder()\n                    self._modify_shot_output_folder(job_id + \"/\" + str(exp))\n\n                    # Here we generate the ciruit\n                    try:\n                        result_draft[\"results\"].append(\n                            self.gen_circuit(exp_dict, job_id)\n                        )\n                    except FileNotFoundError as err:\n                        error_message = str(err)\n                        status_msg_dict.detail += \"; Failed to generate labscript file.\"\n                        status_msg_dict.error_message += f\"; Failed to generate labscript \\\n                            file. Error: {error_message}\"\n                        status_msg_dict.status = \"ERROR\"\n                        result_dict = ResultDict(**result_draft)\n                        return result_dict, status_msg_dict\n                status_msg_dict.detail += \"; Passed json sanity check; Compilation done. \\\n                    Shots sent to solver.\"\n                status_msg_dict.status = \"DONE\"\n                result_dict = ResultDict(**result_draft)\n                return result_dict, status_msg_dict\n\n            status_msg_dict.detail += (\n                \";Failed dimensionality test. Too many atoms. File will be deleted. Error message: \"\n                + dim_err_msg\n            )\n            status_msg_dict.error_message += (\n                \";Failed dimensionality test. Too many atoms. File will be deleted. Error message: \"\n                + dim_err_msg\n            )\n            status_msg_dict.status = \"ERROR\"\n\n            result_dict = ResultDict(**result_draft)\n            return result_dict, status_msg_dict\n\n        status_msg_dict.detail += (\n            \"; Failed json sanity check. File will be deleted. Error message : \"\n            + err_msg\n        )\n        status_msg_dict.error_message += (\n            \"; Failed json sanity check. File will be deleted. Error message : \"\n            + err_msg\n        )\n        status_msg_dict.status = \"ERROR\"\n\n        result_dict = ResultDict(**result_draft)\n        return result_dict, status_msg_dict\n\n    def _modify_shot_output_folder(self, new_dir: str) -&gt; str:\n        \"\"\"\n        I am not sure what this function does.\n\n        Args:\n            new_dir: The new directory under which we save the shots.\n\n        Returns:\n            The path to the new directory.\n        \"\"\"\n\n        # we should simplify this at some point\n        defaut_shot_folder = str(self.remote_client.get_shot_output_folder())\n\n        modified_shot_folder = (defaut_shot_folder.rsplit(\"\\\\\", 1)[0]) + \"/\" + new_dir\n        # suggested better emthod whcih works the same way on all platforms\n        # modified_shot_folder = os.path.join(\n        #    os.path.dirname(defaut_shot_folder), new_dir\n        # )\n        self.remote_client.set_shot_output_folder(modified_shot_folder)\n        return modified_shot_folder\n\n    def gen_circuit(self, json_dict: dict, job_id: str) -&gt; ExperimentDict:\n        \"\"\"\n        This is the main script that generates the labscript file.\n\n        Args:\n            json_dict: The dictionary that contains the instructions for the circuit.\n            job_id: The user id of the user that is running the experiment.\n\n        Returns:\n            The path to the labscript file.\n        \"\"\"\n        # parameters for the function\n        exp_script_folder = self.labscript_params.exp_script_folder\n\n        # local files\n        header_path = f\"{exp_script_folder}/header.py\"\n        remote_experiments_path = f\"{exp_script_folder}/remote_experiments\"\n        # make sure that the folder exists\n        if not os.path.exists(remote_experiments_path):\n            raise FileNotFoundError(\n                f\"The path {remote_experiments_path} does not exist.\"\n            )\n\n        exp_name = next(iter(json_dict))\n        ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n        n_shots = json_dict[next(iter(json_dict))][\"shots\"]\n\n        globals_dict = {\n            \"job_id\": \"guest\",\n            \"shots\": 4,\n        }\n        globals_dict[\"shots\"] = list(range(n_shots))\n        globals_dict[\"job_id\"] = job_id\n\n        self.remote_client.set_globals(globals_dict)\n        script_name = f\"experiment_{globals_dict['job_id']}.py\"\n        exp_script = os.path.join(remote_experiments_path, script_name)\n        ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n        code = \"\"\n        # this is the top part of the script it allows us to import the\n        # typical functions that we require for each single sequence\n        # first have a look if the file exists\n        if not os.path.exists(header_path):\n            raise FileNotFoundError(f\"Header file not found at {header_path}\")\n\n        with open(header_path, \"r\", encoding=\"UTF-8\") as header_file:\n            code = header_file.read()\n\n        # add a line break to the code\n        code += \"\\n\"\n\n        with open(exp_script, \"w\", encoding=\"UTF-8\") as script_file:\n            script_file.write(code)\n\n        for inst in ins_list:\n            # we can directly use the function name as we have already verified\n            # that the function exists in the `add_job` function\n            func_name = inst[0]\n            params = \"(\" + str(inst[1:])[1:-1] + \")\"\n            code = \"Experiment.\" + func_name + params + \"\\n\"\n\n            # we should add proper error handling here\n            # pylint: disable=bare-except\n            try:\n                with open(exp_script, \"a\", encoding=\"UTF-8\") as script_file:\n                    script_file.write(code)\n            except:\n                print(\"Something wrong. Does file path exists?\")\n\n        code = \"Experiment.final_action()\" + \"\\n\" + \"stop(Experiment.t+0.1)\"\n        # pylint: disable=bare-except\n        try:\n            with open(exp_script, \"a\", encoding=\"UTF-8\") as script_file:\n                script_file.write(code)\n        except:\n            print(\"Something wrong. Does file path exists?\")\n        self.remote_client.set_labscript_file(\n            exp_script\n        )  # CAUTION !! This command only selects the file. It does not generate it!\n\n        # be careful. This is not a blocking command\n        self.remote_client.engage()\n\n        # now that we have engaged the calculation we need to wait for the\n        # calculation to be done\n\n        # we need to get the current shot output folder\n        current_shot_folder = self.remote_client.get_shot_output_folder()\n        # we need to get the list of files in the folder\n        hdf5_files = get_file_queue(current_shot_folder)\n\n        # we need to wait until we have the right number of files\n        while len(hdf5_files) &lt; n_shots:\n            sleep(self.labscript_params.t_wait)\n            hdf5_files = get_file_queue(current_shot_folder)\n\n        shots_array = []\n        # once the files are there we can read them\n        for file in hdf5_files:\n            this_run = self.run(current_shot_folder + \"/\" + file)\n            got_nat = False\n            n_tries = 0\n            # sometimes the file is not ready yet. We need to wait a bit\n            while not got_nat and n_tries &lt; 15:\n                # the exception is raised if the file is not ready yet\n                # it is broadly defined within labscript so we cannot do anything about\n                # it here.\n                # pylint: disable=W0718\n                try:\n                    # append the result to the array\n                    shots_array.append(this_run.get_results(\"/measure\", \"nat\"))\n                    got_nat = True\n                except Exception as exc:\n                    print(exc)\n                    sleep(self.labscript_params.t_wait)\n                    n_tries += 1\n\n        exp_sub_dict = create_memory_data(shots_array, exp_name, n_shots)\n        return exp_sub_dict\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.LabscriptSpooler.__init__","title":"<code>__init__(ins_schema_dict, device_config, n_wires, remote_client, labscript_params, run, description='', n_max_shots=1000, version='0.0.1', cold_atom_type='spin', n_max_experiments=15, wire_order='interleaved', num_species=1, operational=True)</code>","text":"<p>The constructor of the class. The  arguments are the same as for the Spooler class with two additions.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def __init__(\n    self,\n    ins_schema_dict: dict,\n    device_config: Type[BaseModel],\n    n_wires: int,\n    remote_client: Any,  # it would be really nice to fix this type\n    labscript_params: LabscriptParams,\n    run: Any,  # it would be really nice to fix this type\n    description: str = \"\",\n    n_max_shots: int = 1000,\n    version: str = \"0.0.1\",\n    cold_atom_type: str = \"spin\",\n    n_max_experiments: int = 15,\n    wire_order: str = \"interleaved\",\n    num_species: int = 1,\n    operational: bool = True,\n):\n    \"\"\"\n    The constructor of the class. The  arguments are the same as for the Spooler\n    class with two additions.\n\n\n    \"\"\"\n    super().__init__(\n        ins_schema_dict,\n        device_config,\n        n_wires,\n        description,\n        n_max_shots,\n        version,\n        cold_atom_type,\n        n_max_experiments,\n        wire_order,\n        num_species,\n        operational,\n    )\n    self.remote_client = remote_client\n    self.labscript_params = labscript_params\n    self.run = run\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.LabscriptSpooler.add_job","title":"<code>add_job(json_dict, status_msg_dict)</code>","text":"<p>The function that translates the json with the instructions into some circuit and executes it. It performs several checks for the job to see if it is properly working. If things are fine the job gets added the list of things that should be executed.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>The job dictonary of all the instructions.</p> required <code>status_msg_dict</code> <code>StatusMsgDict</code> <p>the status dictionary of the job we are treating.</p> required <p>Returns:</p> Name Type Description <code>result_dict</code> <code>ResultDict</code> <p>The dictionary with the results of the job.</p> <code>status_msg_dict</code> <code>StatusMsgDict</code> <p>The status dictionary of the job.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def add_job(\n    self, json_dict: dict, status_msg_dict: StatusMsgDict\n) -&gt; tuple[ResultDict, StatusMsgDict]:\n    \"\"\"\n    The function that translates the json with the instructions into some circuit\n    and executes it. It performs several checks for the job to see if it is properly\n    working. If things are fine the job gets added the list of things that should be\n    executed.\n\n    Args:\n        json_dict: The job dictonary of all the instructions.\n        status_msg_dict: the status dictionary of the job we are treating.\n\n    Returns:\n        result_dict: The dictionary with the results of the job.\n        status_msg_dict: The status dictionary of the job.\n    \"\"\"\n    job_id = status_msg_dict.job_id\n\n    result_draft: dict = {\n        \"display_name\": self.display_name,\n        \"backend_version\": self.version,\n        \"job_id\": job_id,\n        \"qobj_id\": None,\n        \"success\": True,\n        \"status\": \"finished\",\n        \"header\": {},\n        \"results\": [],\n    }\n    err_msg, json_is_fine = self.check_json_dict(json_dict)\n    if json_is_fine:\n        # check_hilbert_space_dimension\n        dim_err_msg, dim_ok = self.check_dimension(json_dict)\n        if dim_ok:\n            for exp in json_dict:\n                exp_dict = {exp: json_dict[exp]}\n                # prepare the shots folder\n                self.remote_client.reset_shot_output_folder()\n                self._modify_shot_output_folder(job_id + \"/\" + str(exp))\n\n                # Here we generate the ciruit\n                try:\n                    result_draft[\"results\"].append(\n                        self.gen_circuit(exp_dict, job_id)\n                    )\n                except FileNotFoundError as err:\n                    error_message = str(err)\n                    status_msg_dict.detail += \"; Failed to generate labscript file.\"\n                    status_msg_dict.error_message += f\"; Failed to generate labscript \\\n                        file. Error: {error_message}\"\n                    status_msg_dict.status = \"ERROR\"\n                    result_dict = ResultDict(**result_draft)\n                    return result_dict, status_msg_dict\n            status_msg_dict.detail += \"; Passed json sanity check; Compilation done. \\\n                Shots sent to solver.\"\n            status_msg_dict.status = \"DONE\"\n            result_dict = ResultDict(**result_draft)\n            return result_dict, status_msg_dict\n\n        status_msg_dict.detail += (\n            \";Failed dimensionality test. Too many atoms. File will be deleted. Error message: \"\n            + dim_err_msg\n        )\n        status_msg_dict.error_message += (\n            \";Failed dimensionality test. Too many atoms. File will be deleted. Error message: \"\n            + dim_err_msg\n        )\n        status_msg_dict.status = \"ERROR\"\n\n        result_dict = ResultDict(**result_draft)\n        return result_dict, status_msg_dict\n\n    status_msg_dict.detail += (\n        \"; Failed json sanity check. File will be deleted. Error message : \"\n        + err_msg\n    )\n    status_msg_dict.error_message += (\n        \"; Failed json sanity check. File will be deleted. Error message : \"\n        + err_msg\n    )\n    status_msg_dict.status = \"ERROR\"\n\n    result_dict = ResultDict(**result_draft)\n    return result_dict, status_msg_dict\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.LabscriptSpooler.gen_circuit","title":"<code>gen_circuit(json_dict, job_id)</code>","text":"<p>This is the main script that generates the labscript file.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>The dictionary that contains the instructions for the circuit.</p> required <code>job_id</code> <code>str</code> <p>The user id of the user that is running the experiment.</p> required <p>Returns:</p> Type Description <code>ExperimentDict</code> <p>The path to the labscript file.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def gen_circuit(self, json_dict: dict, job_id: str) -&gt; ExperimentDict:\n    \"\"\"\n    This is the main script that generates the labscript file.\n\n    Args:\n        json_dict: The dictionary that contains the instructions for the circuit.\n        job_id: The user id of the user that is running the experiment.\n\n    Returns:\n        The path to the labscript file.\n    \"\"\"\n    # parameters for the function\n    exp_script_folder = self.labscript_params.exp_script_folder\n\n    # local files\n    header_path = f\"{exp_script_folder}/header.py\"\n    remote_experiments_path = f\"{exp_script_folder}/remote_experiments\"\n    # make sure that the folder exists\n    if not os.path.exists(remote_experiments_path):\n        raise FileNotFoundError(\n            f\"The path {remote_experiments_path} does not exist.\"\n        )\n\n    exp_name = next(iter(json_dict))\n    ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    n_shots = json_dict[next(iter(json_dict))][\"shots\"]\n\n    globals_dict = {\n        \"job_id\": \"guest\",\n        \"shots\": 4,\n    }\n    globals_dict[\"shots\"] = list(range(n_shots))\n    globals_dict[\"job_id\"] = job_id\n\n    self.remote_client.set_globals(globals_dict)\n    script_name = f\"experiment_{globals_dict['job_id']}.py\"\n    exp_script = os.path.join(remote_experiments_path, script_name)\n    ins_list = json_dict[next(iter(json_dict))][\"instructions\"]\n    code = \"\"\n    # this is the top part of the script it allows us to import the\n    # typical functions that we require for each single sequence\n    # first have a look if the file exists\n    if not os.path.exists(header_path):\n        raise FileNotFoundError(f\"Header file not found at {header_path}\")\n\n    with open(header_path, \"r\", encoding=\"UTF-8\") as header_file:\n        code = header_file.read()\n\n    # add a line break to the code\n    code += \"\\n\"\n\n    with open(exp_script, \"w\", encoding=\"UTF-8\") as script_file:\n        script_file.write(code)\n\n    for inst in ins_list:\n        # we can directly use the function name as we have already verified\n        # that the function exists in the `add_job` function\n        func_name = inst[0]\n        params = \"(\" + str(inst[1:])[1:-1] + \")\"\n        code = \"Experiment.\" + func_name + params + \"\\n\"\n\n        # we should add proper error handling here\n        # pylint: disable=bare-except\n        try:\n            with open(exp_script, \"a\", encoding=\"UTF-8\") as script_file:\n                script_file.write(code)\n        except:\n            print(\"Something wrong. Does file path exists?\")\n\n    code = \"Experiment.final_action()\" + \"\\n\" + \"stop(Experiment.t+0.1)\"\n    # pylint: disable=bare-except\n    try:\n        with open(exp_script, \"a\", encoding=\"UTF-8\") as script_file:\n            script_file.write(code)\n    except:\n        print(\"Something wrong. Does file path exists?\")\n    self.remote_client.set_labscript_file(\n        exp_script\n    )  # CAUTION !! This command only selects the file. It does not generate it!\n\n    # be careful. This is not a blocking command\n    self.remote_client.engage()\n\n    # now that we have engaged the calculation we need to wait for the\n    # calculation to be done\n\n    # we need to get the current shot output folder\n    current_shot_folder = self.remote_client.get_shot_output_folder()\n    # we need to get the list of files in the folder\n    hdf5_files = get_file_queue(current_shot_folder)\n\n    # we need to wait until we have the right number of files\n    while len(hdf5_files) &lt; n_shots:\n        sleep(self.labscript_params.t_wait)\n        hdf5_files = get_file_queue(current_shot_folder)\n\n    shots_array = []\n    # once the files are there we can read them\n    for file in hdf5_files:\n        this_run = self.run(current_shot_folder + \"/\" + file)\n        got_nat = False\n        n_tries = 0\n        # sometimes the file is not ready yet. We need to wait a bit\n        while not got_nat and n_tries &lt; 15:\n            # the exception is raised if the file is not ready yet\n            # it is broadly defined within labscript so we cannot do anything about\n            # it here.\n            # pylint: disable=W0718\n            try:\n                # append the result to the array\n                shots_array.append(this_run.get_results(\"/measure\", \"nat\"))\n                got_nat = True\n            except Exception as exc:\n                print(exc)\n                sleep(self.labscript_params.t_wait)\n                n_tries += 1\n\n    exp_sub_dict = create_memory_data(shots_array, exp_name, n_shots)\n    return exp_sub_dict\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.Spooler","title":"<code>Spooler</code>","text":"<p>             Bases: <code>BaseSpooler</code></p> <p>The class for the spooler as it can be used for simulators.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>class Spooler(BaseSpooler):\n    \"\"\"\n    The class for the spooler as it can be used for simulators.\n    \"\"\"\n\n    @property\n    def gen_circuit(self) -&gt; Callable[[dict], ExperimentDict]:\n        \"\"\"\n        The function that generates the circuit.\n        It can be basically anything that allows the execution of the circuit.\n\n        Returns:\n            The function that generates the circuit.\n\n        Raises:\n            ValueError: if the gen_circuit is not a callable function\n        \"\"\"\n        if not hasattr(self, \"_gen_circuit\"):\n            raise ValueError(\"gen_circuit must be set\")\n        return self._gen_circuit\n\n    @gen_circuit.setter\n    def gen_circuit(self, value: Callable[[dict], ExperimentDict]) -&gt; None:\n        \"\"\"\n        The setter for the gen_circuit function.\n\n        Args:\n            value: The function that generates the circuit.\n        \"\"\"\n        if callable(value):  # Check if the provided value is a callable (function)\n            self._gen_circuit = value\n        else:\n            raise ValueError(\"gen_circuit must be a callable function\")\n\n    def add_job(\n        self, json_dict: dict, status_msg_dict: StatusMsgDict\n    ) -&gt; tuple[ResultDict, StatusMsgDict]:\n        \"\"\"\n        The function that translates the json with the instructions into some circuit and executes it.\n        It performs several checks for the job to see if it is properly working.\n        If things are fine the job gets added the list of things that should be executed.\n\n        Args:\n            json_dict: The job dictonary of all the instructions.\n            status_msg_dict: the status dictionary of the job we are treating.\n\n        Returns:\n            result_dict: The dictionary with the results of the job.\n            status_msg_dict: The status dictionary of the job.\n        \"\"\"\n        job_id = status_msg_dict.job_id\n\n        result_draft: dict = {\n            \"display_name\": self.display_name,\n            \"backend_version\": self.version,\n            \"job_id\": job_id,\n            \"qobj_id\": None,\n            \"success\": True,\n            \"status\": \"finished\",\n            \"header\": {},\n            \"results\": [],\n        }\n        err_msg, json_is_fine = self.check_json_dict(json_dict)\n        if json_is_fine:\n            # check_hilbert_space_dimension\n            dim_err_msg, dim_ok = self.check_dimension(json_dict)\n            if dim_ok:\n                for exp in json_dict:\n                    exp_dict = {exp: json_dict[exp]}\n                    # Here we\n                    try:\n                        # this assumes that we never have more than one argument here.\n                        result_draft[\"results\"].append(self.gen_circuit(exp_dict))\n                    except ValueError as err:\n                        status_msg_dict.detail += \"; \" + str(err)\n                        status_msg_dict.error_message += \"; \" + str(err)\n                        status_msg_dict.status = \"ERROR\"\n                        result_dict = ResultDict(**result_draft)\n                        return result_dict, status_msg_dict\n                status_msg_dict.detail += \"; Passed json sanity check; Compilation done. \\\n                    Shots sent to solver.\"\n                status_msg_dict.status = \"DONE\"\n                result_dict = ResultDict(**result_draft)\n                return result_dict, status_msg_dict\n\n            status_msg_dict.detail += (\n                \"; Failed dimensionality test. Too many atoms. File will be deleted. Error message : \"\n                + dim_err_msg\n            )\n            status_msg_dict.error_message += (\n                \"; Failed dimensionality test. Too many atoms. File will be deleted. Error message :  \"\n                + dim_err_msg\n            )\n            status_msg_dict.status = \"ERROR\"\n            result_dict = ResultDict(**result_draft)\n            return result_dict, status_msg_dict\n        else:\n            status_msg_dict.detail += (\n                \"; Failed json sanity check. File will be deleted. Error message : \"\n                + err_msg\n            )\n            status_msg_dict.error_message += (\n                \"; Failed json sanity check. File will be deleted. Error message : \"\n                + err_msg\n            )\n            status_msg_dict.status = \"ERROR\"\n\n        result_dict = ResultDict(**result_draft)\n        return result_dict, status_msg_dict\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.Spooler.gen_circuit","title":"<code>gen_circuit: Callable[[dict], ExperimentDict]</code>  <code>property</code> <code>writable</code>","text":"<p>The function that generates the circuit. It can be basically anything that allows the execution of the circuit.</p> <p>Returns:</p> Type Description <code>Callable[[dict], ExperimentDict]</code> <p>The function that generates the circuit.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the gen_circuit is not a callable function</p>"},{"location":"spoolers/#src.sqooler.spoolers.Spooler.add_job","title":"<code>add_job(json_dict, status_msg_dict)</code>","text":"<p>The function that translates the json with the instructions into some circuit and executes it. It performs several checks for the job to see if it is properly working. If things are fine the job gets added the list of things that should be executed.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>The job dictonary of all the instructions.</p> required <code>status_msg_dict</code> <code>StatusMsgDict</code> <p>the status dictionary of the job we are treating.</p> required <p>Returns:</p> Name Type Description <code>result_dict</code> <code>ResultDict</code> <p>The dictionary with the results of the job.</p> <code>status_msg_dict</code> <code>StatusMsgDict</code> <p>The status dictionary of the job.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def add_job(\n    self, json_dict: dict, status_msg_dict: StatusMsgDict\n) -&gt; tuple[ResultDict, StatusMsgDict]:\n    \"\"\"\n    The function that translates the json with the instructions into some circuit and executes it.\n    It performs several checks for the job to see if it is properly working.\n    If things are fine the job gets added the list of things that should be executed.\n\n    Args:\n        json_dict: The job dictonary of all the instructions.\n        status_msg_dict: the status dictionary of the job we are treating.\n\n    Returns:\n        result_dict: The dictionary with the results of the job.\n        status_msg_dict: The status dictionary of the job.\n    \"\"\"\n    job_id = status_msg_dict.job_id\n\n    result_draft: dict = {\n        \"display_name\": self.display_name,\n        \"backend_version\": self.version,\n        \"job_id\": job_id,\n        \"qobj_id\": None,\n        \"success\": True,\n        \"status\": \"finished\",\n        \"header\": {},\n        \"results\": [],\n    }\n    err_msg, json_is_fine = self.check_json_dict(json_dict)\n    if json_is_fine:\n        # check_hilbert_space_dimension\n        dim_err_msg, dim_ok = self.check_dimension(json_dict)\n        if dim_ok:\n            for exp in json_dict:\n                exp_dict = {exp: json_dict[exp]}\n                # Here we\n                try:\n                    # this assumes that we never have more than one argument here.\n                    result_draft[\"results\"].append(self.gen_circuit(exp_dict))\n                except ValueError as err:\n                    status_msg_dict.detail += \"; \" + str(err)\n                    status_msg_dict.error_message += \"; \" + str(err)\n                    status_msg_dict.status = \"ERROR\"\n                    result_dict = ResultDict(**result_draft)\n                    return result_dict, status_msg_dict\n            status_msg_dict.detail += \"; Passed json sanity check; Compilation done. \\\n                Shots sent to solver.\"\n            status_msg_dict.status = \"DONE\"\n            result_dict = ResultDict(**result_draft)\n            return result_dict, status_msg_dict\n\n        status_msg_dict.detail += (\n            \"; Failed dimensionality test. Too many atoms. File will be deleted. Error message : \"\n            + dim_err_msg\n        )\n        status_msg_dict.error_message += (\n            \"; Failed dimensionality test. Too many atoms. File will be deleted. Error message :  \"\n            + dim_err_msg\n        )\n        status_msg_dict.status = \"ERROR\"\n        result_dict = ResultDict(**result_draft)\n        return result_dict, status_msg_dict\n    else:\n        status_msg_dict.detail += (\n            \"; Failed json sanity check. File will be deleted. Error message : \"\n            + err_msg\n        )\n        status_msg_dict.error_message += (\n            \"; Failed json sanity check. File will be deleted. Error message : \"\n            + err_msg\n        )\n        status_msg_dict.status = \"ERROR\"\n\n    result_dict = ResultDict(**result_draft)\n    return result_dict, status_msg_dict\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.create_memory_data","title":"<code>create_memory_data(shots_array, exp_name, n_shots)</code>","text":"<p>The function to create memory key in results dictionary with proprer formatting.</p> <p>Parameters:</p> Name Type Description Default <code>shots_array</code> <code>list</code> <p>The array with the shots.</p> required <code>exp_name</code> <code>str</code> <p>The name of the experiment.</p> required <code>n_shots</code> <code>int</code> <p>The number of shots.</p> required <p>Returns:</p> Type Description <code>ExperimentDict</code> <p>The ExperimentDict object describing the results.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def create_memory_data(\n    shots_array: list, exp_name: str, n_shots: int\n) -&gt; ExperimentDict:\n    \"\"\"\n    The function to create memory key in results dictionary\n    with proprer formatting.\n\n    Args:\n        shots_array: The array with the shots.\n        exp_name: The name of the experiment.\n        n_shots: The number of shots.\n\n    Returns:\n        The ExperimentDict object describing the results.\n    \"\"\"\n    exp_sub_dict: dict = {\n        \"header\": {\"name\": \"experiment_0\", \"extra metadata\": \"text\"},\n        \"shots\": 3,\n        \"success\": True,\n        \"data\": {\"memory\": None},\n    }\n\n    exp_sub_dict[\"header\"][\"name\"] = exp_name\n    exp_sub_dict[\"shots\"] = n_shots\n    memory_list = [\n        str(shot).replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \"\")\n        for shot in shots_array\n    ]\n    exp_sub_dict[\"data\"][\"memory\"] = memory_list\n    return ExperimentDict(**exp_sub_dict)\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.gate_dict_from_list","title":"<code>gate_dict_from_list(inst_list)</code>","text":"<p>Transforms a list into an appropiate dictionnary for instructions. The list is assumed to be in the format [name, wires, params].</p> <p>Parameters:</p> Name Type Description Default <code>inst_list</code> <code>list</code> <p>The list that should be transformed.</p> required <p>Returns:</p> Type Description <code>GateDict</code> <p>A GateDict object.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def gate_dict_from_list(inst_list: list) -&gt; GateDict:\n    \"\"\"\n    Transforms a list into an appropiate dictionnary for instructions. The list\n    is assumed to be in the format [name, wires, params].\n\n    Args:\n        inst_list: The list that should be transformed.\n\n    Returns:\n        A GateDict object.\n    \"\"\"\n    gate_draft = {\"name\": inst_list[0], \"wires\": inst_list[1], \"params\": inst_list[2]}\n    return GateDict(**gate_draft)\n</code></pre>"},{"location":"spoolers/#src.sqooler.spoolers.get_file_queue","title":"<code>get_file_queue(dir_path)</code>","text":"<p>A function that returns the list of files in the directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>The path to the directory.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of files in the directory. It excludes directories.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a directory.</p> Source code in <code>src/sqooler/spoolers.py</code> <pre><code>def get_file_queue(dir_path: str) -&gt; list[str]:\n    \"\"\"\n    A function that returns the list of files in the directory.\n\n    Args:\n        dir_path: The path to the directory.\n\n    Returns:\n        A list of files in the directory. It excludes directories.\n\n    Raises:\n        ValueError: If the path is not a directory.\n    \"\"\"\n\n    # make sure that the path is an existing directory\n    if not os.path.isdir(dir_path):\n        raise ValueError(f\"The path {dir_path} is not a directory.\")\n    files = [\n        file\n        for file in os.listdir(dir_path)\n        if os.path.isfile(os.path.join(dir_path, file))\n    ]\n    return files\n</code></pre>"},{"location":"storage_providers/","title":"API documentation of storage providers","text":""},{"location":"utils/","title":"API documentation of utils","text":"<p>This module contains some functions that are especially helpful for deployment of the  sqooler package.</p>"},{"location":"utils/#src.sqooler.utils.main","title":"<code>main(storage_provider, backends, num_iter=0)</code>","text":"<p>Function for processing jobs continuously.</p> <p>Parameters:</p> Name Type Description Default <code>storage_provider</code> <code>StorageProvider</code> <p>The storage provider that should be used.</p> required <code>backends</code> <code>dict[str, Spooler]</code> <p>A dictionary of all the backends that should be updated.</p> required <code>num_iter</code> <code>int</code> <p>The number of iterations that should be done. If 0, then the loop will run forever.</p> <code>0</code> Source code in <code>src/sqooler/utils.py</code> <pre><code>def main(\n    storage_provider: StorageProvider,\n    backends: dict[str, Spooler],\n    num_iter: int = 0,\n) -&gt; None:\n    \"\"\"\n    Function for processing jobs continuously.\n\n    Args:\n        storage_provider: The storage provider that should be used.\n        backends: A dictionary of all the backends that should be updated.\n        num_iter: The number of iterations that should be done. If 0, then the loop\n            will run forever.\n    \"\"\"\n    backends_list = list(backends.keys())\n\n    # set the appropiate display names for all the back-ends\n    for requested_backend, spooler in backends.items():\n        # the content\n        spooler.display_name = requested_backend\n\n    counter = 0\n    # loop which is looking for the jobs\n    while num_iter == 0 or counter &lt; num_iter:\n        time.sleep(0.2)\n\n        # the following a fancy for loop of going through all the back-ends in the list\n        requested_backend = backends_list[0]\n        backends_list.append(backends_list.pop(0))\n        # let us first see if jobs are waiting\n        job_dict = storage_provider.get_next_job_in_queue(requested_backend)\n        if job_dict[\"job_json_path\"] == \"None\":\n            continue\n        job_json_dict = storage_provider.get_job_content(\n            storage_path=job_dict[\"job_json_path\"], job_id=job_dict[\"job_id\"]\n        )\n\n        result_draft: dict = {\n            \"display_name\": \"\",\n            \"backend_version\": \"\",\n            \"job_id\": \"\",\n            \"qobj_id\": None,\n            \"success\": True,\n            \"status\": \"finished\",\n            \"header\": {},\n            \"results\": [],\n        }\n\n        result_dict = ResultDict(**result_draft)\n        status_msg_draft = {\n            \"job_id\": job_dict[\"job_id\"],\n            \"status\": \"None\",\n            \"detail\": \"None\",\n            \"error_message\": \"None\",\n        }\n        status_msg_dict = StatusMsgDict(**status_msg_draft)\n        # Fix this pylint issue whenever you have time, but be careful !\n        # pylint: disable=W0703\n        try:\n            result_dict, status_msg_dict = backends[requested_backend].add_job(\n                job_json_dict, status_msg_dict\n            )\n\n        except Exception:\n            # Remove sensitive info like filepaths\n            tb_list = traceback.format_exc().splitlines()\n            for i, dummy in enumerate(tb_list):\n                tb_list[i] = re.sub(\n                    r'File \".*[\\\\/]([^\\\\/]+.py)\"', r'File \"\\1\"', tb_list[i]\n                )  # Regex for repalcing absolute filepath with only filename.\n                # Basically search for slashes and replace with the first group or\n                # bracketed expression which is obviously the filename.\n            slimmed_tb = \" \".join(tb_list)\n            # Update status dict\n            status_msg_dict.status = \"ERROR\"\n            status_msg_dict.detail += \"; \" + slimmed_tb\n            status_msg_dict.error_message += \"; \" + slimmed_tb\n\n        storage_provider.update_in_database(\n            result_dict, status_msg_dict, job_dict[\"job_id\"], requested_backend\n        )\n\n        counter += 1\n</code></pre>"},{"location":"utils/#src.sqooler.utils.run_json_circuit","title":"<code>run_json_circuit(json_dict, job_id, spooler)</code>","text":"<p>A support function that executes the job. Should be only used for testing.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>the job dict that will be treated</p> required <code>job_id</code> <code>str</code> <p>the number of the job</p> required <code>spooler</code> <code>Spooler</code> <p>the spooler that will be used</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the results dict</p> Source code in <code>src/sqooler/utils.py</code> <pre><code>def run_json_circuit(json_dict: dict, job_id: str, spooler: Spooler) -&gt; dict:\n    \"\"\"\n    A support function that executes the job. Should be only used for testing.\n\n    Args:\n        json_dict: the job dict that will be treated\n        job_id: the number of the job\n        spooler: the spooler that will be used\n\n    Returns:\n        the results dict\n    \"\"\"\n    status_msg_draft = {\n        \"job_id\": job_id,\n        \"status\": \"None\",\n        \"detail\": \"None\",\n        \"error_message\": \"None\",\n    }\n    status_msg_dict = StatusMsgDict(**status_msg_draft)\n\n    result_dict, status_msg_dict = spooler.add_job(json_dict, status_msg_dict)\n    assert status_msg_dict.status == \"DONE\", \"Job failed\"\n    return result_dict.model_dump()\n</code></pre>"},{"location":"utils/#src.sqooler.utils.update_backends","title":"<code>update_backends(storage_provider, backends)</code>","text":"<p>Update the backends on the storage.</p> <p>Parameters:</p> Name Type Description Default <code>storage_provider</code> <code>StorageProvider</code> <p>The storage provider that should be used.</p> required <code>backends</code> <code>dict[str, Spooler]</code> <p>A dictionary of all the backends that should be updated.</p> required Source code in <code>src/sqooler/utils.py</code> <pre><code>def update_backends(\n    storage_provider: StorageProvider, backends: dict[str, Spooler]\n) -&gt; None:\n    \"\"\"\n    Update the backends on the storage.\n\n    Args:\n        storage_provider: The storage provider that should be used.\n        backends: A dictionary of all the backends that should be updated.\n    \"\"\"\n    for requested_backend, spooler in backends.items():\n        # the content\n        backend_config_dict = spooler.get_configuration()\n        # set the display name\n        backend_config_dict.display_name = requested_backend\n\n        # upload the content through the storage provider\n        storage_provider.upload_config(backend_config_dict, requested_backend)\n</code></pre>"}]}